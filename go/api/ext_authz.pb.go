// Code generated by protoc-gen-go. DO NOT EDIT.
// versions:
// 	protoc-gen-go v1.36.11
// 	protoc        (unknown)
// source: ext_authz.proto

package authv3

import (
	protoreflect "google.golang.org/protobuf/reflect/protoreflect"
	protoimpl "google.golang.org/protobuf/runtime/protoimpl"
	anypb "google.golang.org/protobuf/types/known/anypb"
	_ "google.golang.org/protobuf/types/known/durationpb"
	structpb "google.golang.org/protobuf/types/known/structpb"
	timestamppb "google.golang.org/protobuf/types/known/timestamppb"
	wrapperspb "google.golang.org/protobuf/types/known/wrapperspb"
	reflect "reflect"
	sync "sync"
	unsafe "unsafe"
)

const (
	// Verify that this generated code is sufficiently up-to-date.
	_ = protoimpl.EnforceVersion(20 - protoimpl.MinVersion)
	// Verify that runtime/protoimpl is sufficiently up-to-date.
	_ = protoimpl.EnforceVersion(protoimpl.MaxVersion - 20)
)

type StatusCode int32

const (
	// Empty - This code not part of the HTTP status code specification, but it is needed for proto
	// `enum` type.
	StatusCode_Empty StatusCode = 0
	// Continue - “100“ status code.
	StatusCode_Continue StatusCode = 100
	// OK - “200“ status code.
	StatusCode_OK StatusCode = 200
	// Created - “201“ status code.
	StatusCode_Created StatusCode = 201
	// Accepted - “202“ status code.
	StatusCode_Accepted StatusCode = 202
	// NonAuthoritativeInformation - “203“ status code.
	StatusCode_NonAuthoritativeInformation StatusCode = 203
	// NoContent - “204“ status code.
	StatusCode_NoContent StatusCode = 204
	// ResetContent - “205“ status code.
	StatusCode_ResetContent StatusCode = 205
	// PartialContent - “206“ status code.
	StatusCode_PartialContent StatusCode = 206
	// MultiStatus - “207“ status code.
	StatusCode_MultiStatus StatusCode = 207
	// AlreadyReported - “208“ status code.
	StatusCode_AlreadyReported StatusCode = 208
	// IMUsed - “226“ status code.
	StatusCode_IMUsed StatusCode = 226
	// MultipleChoices - “300“ status code.
	StatusCode_MultipleChoices StatusCode = 300
	// MovedPermanently - “301“ status code.
	StatusCode_MovedPermanently StatusCode = 301
	// Found - “302“ status code.
	StatusCode_Found StatusCode = 302
	// SeeOther - “303“ status code.
	StatusCode_SeeOther StatusCode = 303
	// NotModified - “304“ status code.
	StatusCode_NotModified StatusCode = 304
	// UseProxy - “305“ status code.
	StatusCode_UseProxy StatusCode = 305
	// TemporaryRedirect - “307“ status code.
	StatusCode_TemporaryRedirect StatusCode = 307
	// PermanentRedirect - “308“ status code.
	StatusCode_PermanentRedirect StatusCode = 308
	// BadRequest - “400“ status code.
	StatusCode_BadRequest StatusCode = 400
	// Unauthorized - “401“ status code.
	StatusCode_Unauthorized StatusCode = 401
	// PaymentRequired - “402“ status code.
	StatusCode_PaymentRequired StatusCode = 402
	// Forbidden - “403“ status code.
	StatusCode_Forbidden StatusCode = 403
	// NotFound - “404“ status code.
	StatusCode_NotFound StatusCode = 404
	// MethodNotAllowed - “405“ status code.
	StatusCode_MethodNotAllowed StatusCode = 405
	// NotAcceptable - “406“ status code.
	StatusCode_NotAcceptable StatusCode = 406
	// ProxyAuthenticationRequired - “407“ status code.
	StatusCode_ProxyAuthenticationRequired StatusCode = 407
	// RequestTimeout - “408“ status code.
	StatusCode_RequestTimeout StatusCode = 408
	// Conflict - “409“ status code.
	StatusCode_Conflict StatusCode = 409
	// Gone - “410“ status code.
	StatusCode_Gone StatusCode = 410
	// LengthRequired - “411“ status code.
	StatusCode_LengthRequired StatusCode = 411
	// PreconditionFailed - “412“ status code.
	StatusCode_PreconditionFailed StatusCode = 412
	// PayloadTooLarge - “413“ status code.
	StatusCode_PayloadTooLarge StatusCode = 413
	// URITooLong - “414“ status code.
	StatusCode_URITooLong StatusCode = 414
	// UnsupportedMediaType - “415“ status code.
	StatusCode_UnsupportedMediaType StatusCode = 415
	// RangeNotSatisfiable - “416“ status code.
	StatusCode_RangeNotSatisfiable StatusCode = 416
	// ExpectationFailed - “417“ status code.
	StatusCode_ExpectationFailed StatusCode = 417
	// MisdirectedRequest - “421“ status code.
	StatusCode_MisdirectedRequest StatusCode = 421
	// UnprocessableEntity - “422“ status code.
	StatusCode_UnprocessableEntity StatusCode = 422
	// Locked - “423“ status code.
	StatusCode_Locked StatusCode = 423
	// FailedDependency - “424“ status code.
	StatusCode_FailedDependency StatusCode = 424
	// UpgradeRequired - “426“ status code.
	StatusCode_UpgradeRequired StatusCode = 426
	// PreconditionRequired - “428“ status code.
	StatusCode_PreconditionRequired StatusCode = 428
	// TooManyRequests - “429“ status code.
	StatusCode_TooManyRequests StatusCode = 429
	// RequestHeaderFieldsTooLarge - “431“ status code.
	StatusCode_RequestHeaderFieldsTooLarge StatusCode = 431
	// InternalServerError - “500“ status code.
	StatusCode_InternalServerError StatusCode = 500
	// NotImplemented - “501“ status code.
	StatusCode_NotImplemented StatusCode = 501
	// BadGateway - “502“ status code.
	StatusCode_BadGateway StatusCode = 502
	// ServiceUnavailable - “503“ status code.
	StatusCode_ServiceUnavailable StatusCode = 503
	// GatewayTimeout - “504“ status code.
	StatusCode_GatewayTimeout StatusCode = 504
	// HTTPVersionNotSupported - “505“ status code.
	StatusCode_HTTPVersionNotSupported StatusCode = 505
	// VariantAlsoNegotiates - “506“ status code.
	StatusCode_VariantAlsoNegotiates StatusCode = 506
	// InsufficientStorage - “507“ status code.
	StatusCode_InsufficientStorage StatusCode = 507
	// LoopDetected - “508“ status code.
	StatusCode_LoopDetected StatusCode = 508
	// NotExtended - “510“ status code.
	StatusCode_NotExtended StatusCode = 510
	// NetworkAuthenticationRequired - “511“ status code.
	StatusCode_NetworkAuthenticationRequired StatusCode = 511
)

// Enum value maps for StatusCode.
var (
	StatusCode_name = map[int32]string{
		0:   "Empty",
		100: "Continue",
		200: "OK",
		201: "Created",
		202: "Accepted",
		203: "NonAuthoritativeInformation",
		204: "NoContent",
		205: "ResetContent",
		206: "PartialContent",
		207: "MultiStatus",
		208: "AlreadyReported",
		226: "IMUsed",
		300: "MultipleChoices",
		301: "MovedPermanently",
		302: "Found",
		303: "SeeOther",
		304: "NotModified",
		305: "UseProxy",
		307: "TemporaryRedirect",
		308: "PermanentRedirect",
		400: "BadRequest",
		401: "Unauthorized",
		402: "PaymentRequired",
		403: "Forbidden",
		404: "NotFound",
		405: "MethodNotAllowed",
		406: "NotAcceptable",
		407: "ProxyAuthenticationRequired",
		408: "RequestTimeout",
		409: "Conflict",
		410: "Gone",
		411: "LengthRequired",
		412: "PreconditionFailed",
		413: "PayloadTooLarge",
		414: "URITooLong",
		415: "UnsupportedMediaType",
		416: "RangeNotSatisfiable",
		417: "ExpectationFailed",
		421: "MisdirectedRequest",
		422: "UnprocessableEntity",
		423: "Locked",
		424: "FailedDependency",
		426: "UpgradeRequired",
		428: "PreconditionRequired",
		429: "TooManyRequests",
		431: "RequestHeaderFieldsTooLarge",
		500: "InternalServerError",
		501: "NotImplemented",
		502: "BadGateway",
		503: "ServiceUnavailable",
		504: "GatewayTimeout",
		505: "HTTPVersionNotSupported",
		506: "VariantAlsoNegotiates",
		507: "InsufficientStorage",
		508: "LoopDetected",
		510: "NotExtended",
		511: "NetworkAuthenticationRequired",
	}
	StatusCode_value = map[string]int32{
		"Empty":                         0,
		"Continue":                      100,
		"OK":                            200,
		"Created":                       201,
		"Accepted":                      202,
		"NonAuthoritativeInformation":   203,
		"NoContent":                     204,
		"ResetContent":                  205,
		"PartialContent":                206,
		"MultiStatus":                   207,
		"AlreadyReported":               208,
		"IMUsed":                        226,
		"MultipleChoices":               300,
		"MovedPermanently":              301,
		"Found":                         302,
		"SeeOther":                      303,
		"NotModified":                   304,
		"UseProxy":                      305,
		"TemporaryRedirect":             307,
		"PermanentRedirect":             308,
		"BadRequest":                    400,
		"Unauthorized":                  401,
		"PaymentRequired":               402,
		"Forbidden":                     403,
		"NotFound":                      404,
		"MethodNotAllowed":              405,
		"NotAcceptable":                 406,
		"ProxyAuthenticationRequired":   407,
		"RequestTimeout":                408,
		"Conflict":                      409,
		"Gone":                          410,
		"LengthRequired":                411,
		"PreconditionFailed":            412,
		"PayloadTooLarge":               413,
		"URITooLong":                    414,
		"UnsupportedMediaType":          415,
		"RangeNotSatisfiable":           416,
		"ExpectationFailed":             417,
		"MisdirectedRequest":            421,
		"UnprocessableEntity":           422,
		"Locked":                        423,
		"FailedDependency":              424,
		"UpgradeRequired":               426,
		"PreconditionRequired":          428,
		"TooManyRequests":               429,
		"RequestHeaderFieldsTooLarge":   431,
		"InternalServerError":           500,
		"NotImplemented":                501,
		"BadGateway":                    502,
		"ServiceUnavailable":            503,
		"GatewayTimeout":                504,
		"HTTPVersionNotSupported":       505,
		"VariantAlsoNegotiates":         506,
		"InsufficientStorage":           507,
		"LoopDetected":                  508,
		"NotExtended":                   510,
		"NetworkAuthenticationRequired": 511,
	}
)

func (x StatusCode) Enum() *StatusCode {
	p := new(StatusCode)
	*p = x
	return p
}

func (x StatusCode) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (StatusCode) Descriptor() protoreflect.EnumDescriptor {
	return file_ext_authz_proto_enumTypes[0].Descriptor()
}

func (StatusCode) Type() protoreflect.EnumType {
	return &file_ext_authz_proto_enumTypes[0]
}

func (x StatusCode) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use StatusCode.Descriptor instead.
func (StatusCode) EnumDescriptor() ([]byte, []int) {
	return file_ext_authz_proto_rawDescGZIP(), []int{0}
}

// Describes the supported actions types for header append action.
type HeaderValueOption_HeaderAppendAction int32

const (
	// If the header already exists, this action will result in:
	//
	// - Comma-concatenated for predefined inline headers.
	// - Duplicate header added in the “HeaderMap“ for other headers.
	//
	// If the header doesn't exist then this will add new header with specified key and value.
	HeaderValueOption_APPEND_IF_EXISTS_OR_ADD HeaderValueOption_HeaderAppendAction = 0
	// This action will add the header if it doesn't already exist. If the header
	// already exists then this will be a no-op.
	HeaderValueOption_ADD_IF_ABSENT HeaderValueOption_HeaderAppendAction = 1
	// This action will overwrite the specified value by discarding any existing values if
	// the header already exists. If the header doesn't exist then this will add the header
	// with specified key and value.
	HeaderValueOption_OVERWRITE_IF_EXISTS_OR_ADD HeaderValueOption_HeaderAppendAction = 2
	// This action will overwrite the specified value by discarding any existing values if
	// the header already exists. If the header doesn't exist then this will be no-op.
	HeaderValueOption_OVERWRITE_IF_EXISTS HeaderValueOption_HeaderAppendAction = 3
)

// Enum value maps for HeaderValueOption_HeaderAppendAction.
var (
	HeaderValueOption_HeaderAppendAction_name = map[int32]string{
		0: "APPEND_IF_EXISTS_OR_ADD",
		1: "ADD_IF_ABSENT",
		2: "OVERWRITE_IF_EXISTS_OR_ADD",
		3: "OVERWRITE_IF_EXISTS",
	}
	HeaderValueOption_HeaderAppendAction_value = map[string]int32{
		"APPEND_IF_EXISTS_OR_ADD":    0,
		"ADD_IF_ABSENT":              1,
		"OVERWRITE_IF_EXISTS_OR_ADD": 2,
		"OVERWRITE_IF_EXISTS":        3,
	}
)

func (x HeaderValueOption_HeaderAppendAction) Enum() *HeaderValueOption_HeaderAppendAction {
	p := new(HeaderValueOption_HeaderAppendAction)
	*p = x
	return p
}

func (x HeaderValueOption_HeaderAppendAction) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (HeaderValueOption_HeaderAppendAction) Descriptor() protoreflect.EnumDescriptor {
	return file_ext_authz_proto_enumTypes[1].Descriptor()
}

func (HeaderValueOption_HeaderAppendAction) Type() protoreflect.EnumType {
	return &file_ext_authz_proto_enumTypes[1]
}

func (x HeaderValueOption_HeaderAppendAction) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use HeaderValueOption_HeaderAppendAction.Descriptor instead.
func (HeaderValueOption_HeaderAppendAction) EnumDescriptor() ([]byte, []int) {
	return file_ext_authz_proto_rawDescGZIP(), []int{7, 0}
}

type SocketAddress_Protocol int32

const (
	SocketAddress_TCP SocketAddress_Protocol = 0
	SocketAddress_UDP SocketAddress_Protocol = 1
)

// Enum value maps for SocketAddress_Protocol.
var (
	SocketAddress_Protocol_name = map[int32]string{
		0: "TCP",
		1: "UDP",
	}
	SocketAddress_Protocol_value = map[string]int32{
		"TCP": 0,
		"UDP": 1,
	}
)

func (x SocketAddress_Protocol) Enum() *SocketAddress_Protocol {
	p := new(SocketAddress_Protocol)
	*p = x
	return p
}

func (x SocketAddress_Protocol) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (SocketAddress_Protocol) Descriptor() protoreflect.EnumDescriptor {
	return file_ext_authz_proto_enumTypes[2].Descriptor()
}

func (SocketAddress_Protocol) Type() protoreflect.EnumType {
	return &file_ext_authz_proto_enumTypes[2]
}

func (x SocketAddress_Protocol) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use SocketAddress_Protocol.Descriptor instead.
func (SocketAddress_Protocol) EnumDescriptor() ([]byte, []int) {
	return file_ext_authz_proto_rawDescGZIP(), []int{11, 0}
}

type CheckRequest struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// The request attributes.
	Attributes    *AttributeContext `protobuf:"bytes,1,opt,name=attributes,proto3" json:"attributes,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *CheckRequest) Reset() {
	*x = CheckRequest{}
	mi := &file_ext_authz_proto_msgTypes[0]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *CheckRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*CheckRequest) ProtoMessage() {}

func (x *CheckRequest) ProtoReflect() protoreflect.Message {
	mi := &file_ext_authz_proto_msgTypes[0]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use CheckRequest.ProtoReflect.Descriptor instead.
func (*CheckRequest) Descriptor() ([]byte, []int) {
	return file_ext_authz_proto_rawDescGZIP(), []int{0}
}

func (x *CheckRequest) GetAttributes() *AttributeContext {
	if x != nil {
		return x.Attributes
	}
	return nil
}

// HTTP attributes for a denied response.
type DeniedHttpResponse struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// This field allows the authorization service to send an HTTP response status code to the
	// downstream client. If not set, Envoy sends “403 Forbidden“ HTTP status code by default.
	Status *HttpStatus `protobuf:"bytes,1,opt,name=status,proto3" json:"status,omitempty"`
	// This field allows the authorization service to send HTTP response headers
	// to the downstream client. Note that the :ref:`append field in HeaderValueOption <envoy_v3_api_field_config.core.v3.HeaderValueOption.append>` defaults to
	// false when used in this message.
	Headers []*HeaderValueOption `protobuf:"bytes,2,rep,name=headers,proto3" json:"headers,omitempty"`
	// This field allows the authorization service to send a response body data
	// to the downstream client.
	Body          string `protobuf:"bytes,3,opt,name=body,proto3" json:"body,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *DeniedHttpResponse) Reset() {
	*x = DeniedHttpResponse{}
	mi := &file_ext_authz_proto_msgTypes[1]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *DeniedHttpResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*DeniedHttpResponse) ProtoMessage() {}

func (x *DeniedHttpResponse) ProtoReflect() protoreflect.Message {
	mi := &file_ext_authz_proto_msgTypes[1]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use DeniedHttpResponse.ProtoReflect.Descriptor instead.
func (*DeniedHttpResponse) Descriptor() ([]byte, []int) {
	return file_ext_authz_proto_rawDescGZIP(), []int{1}
}

func (x *DeniedHttpResponse) GetStatus() *HttpStatus {
	if x != nil {
		return x.Status
	}
	return nil
}

func (x *DeniedHttpResponse) GetHeaders() []*HeaderValueOption {
	if x != nil {
		return x.Headers
	}
	return nil
}

func (x *DeniedHttpResponse) GetBody() string {
	if x != nil {
		return x.Body
	}
	return ""
}

// HTTP attributes for an OK response.
// [#next-free-field: 9]
type OkHttpResponse struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// HTTP entity headers in addition to the original request headers. This allows the authorization
	// service to append, to add or to override headers from the original request before
	// dispatching it to the upstream. Note that the :ref:`append field in HeaderValueOption <envoy_v3_api_field_HeaderValueOption.append>` defaults to
	// false when used in this message. By setting the “append“ field to “true“,
	// the filter will append the correspondent header value to the matched request header.
	// By leaving “append“ as false, the filter will either add a new header, or override an existing
	// one if there is a match.
	Headers []*HeaderValueOption `protobuf:"bytes,2,rep,name=headers,proto3" json:"headers,omitempty"`
	// HTTP entity headers to remove from the original request before dispatching
	// it to the upstream. This allows the authorization service to act on auth
	// related headers (like “Authorization“), process them, and consume them.
	// Under this model, the upstream will either receive the request (if it's
	// authorized) or not receive it (if it's not), but will not see headers
	// containing authorization credentials.
	//
	// Pseudo headers (such as “:authority“, “:method“, “:path“ etc), as well as
	// the header “Host“, may not be removed as that would make the request
	// malformed. If mentioned in “headers_to_remove“ these special headers will
	// be ignored.
	//
	// When using the HTTP service this must instead be set by the HTTP
	// authorization service as a comma separated list like so:
	// “x-envoy-auth-headers-to-remove: one-auth-header, another-auth-header“.
	HeadersToRemove []string `protobuf:"bytes,5,rep,name=headers_to_remove,json=headersToRemove,proto3" json:"headers_to_remove,omitempty"`
	// This field has been deprecated in favor of :ref:`CheckResponse.dynamic_metadata
	// <envoy_v3_api_field_service.auth.v3.CheckResponse.dynamic_metadata>`. Until it is removed,
	// setting this field overrides :ref:`CheckResponse.dynamic_metadata
	// <envoy_v3_api_field_service.auth.v3.CheckResponse.dynamic_metadata>`.
	//
	// Deprecated: Marked as deprecated in ext_authz.proto.
	DynamicMetadata *structpb.Struct `protobuf:"bytes,3,opt,name=dynamic_metadata,json=dynamicMetadata,proto3" json:"dynamic_metadata,omitempty"`
	// This field allows the authorization service to send HTTP response headers
	// to the downstream client on success. Note that the :ref:`append field in HeaderValueOption <envoy_v3_api_field_config.core.v3.HeaderValueOption.append>`
	// defaults to false when used in this message.
	ResponseHeadersToAdd []*HeaderValueOption `protobuf:"bytes,6,rep,name=response_headers_to_add,json=responseHeadersToAdd,proto3" json:"response_headers_to_add,omitempty"`
	// This field allows the authorization service to set (and overwrite) query
	// string parameters on the original request before it is sent upstream.
	QueryParametersToSet []*QueryParameter `protobuf:"bytes,7,rep,name=query_parameters_to_set,json=queryParametersToSet,proto3" json:"query_parameters_to_set,omitempty"`
	// This field allows the authorization service to specify which query parameters
	// should be removed from the original request before it is sent upstream. Each
	// element in this list is a case-sensitive query parameter name to be removed.
	QueryParametersToRemove []string `protobuf:"bytes,8,rep,name=query_parameters_to_remove,json=queryParametersToRemove,proto3" json:"query_parameters_to_remove,omitempty"`
	unknownFields           protoimpl.UnknownFields
	sizeCache               protoimpl.SizeCache
}

func (x *OkHttpResponse) Reset() {
	*x = OkHttpResponse{}
	mi := &file_ext_authz_proto_msgTypes[2]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *OkHttpResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*OkHttpResponse) ProtoMessage() {}

func (x *OkHttpResponse) ProtoReflect() protoreflect.Message {
	mi := &file_ext_authz_proto_msgTypes[2]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use OkHttpResponse.ProtoReflect.Descriptor instead.
func (*OkHttpResponse) Descriptor() ([]byte, []int) {
	return file_ext_authz_proto_rawDescGZIP(), []int{2}
}

func (x *OkHttpResponse) GetHeaders() []*HeaderValueOption {
	if x != nil {
		return x.Headers
	}
	return nil
}

func (x *OkHttpResponse) GetHeadersToRemove() []string {
	if x != nil {
		return x.HeadersToRemove
	}
	return nil
}

// Deprecated: Marked as deprecated in ext_authz.proto.
func (x *OkHttpResponse) GetDynamicMetadata() *structpb.Struct {
	if x != nil {
		return x.DynamicMetadata
	}
	return nil
}

func (x *OkHttpResponse) GetResponseHeadersToAdd() []*HeaderValueOption {
	if x != nil {
		return x.ResponseHeadersToAdd
	}
	return nil
}

func (x *OkHttpResponse) GetQueryParametersToSet() []*QueryParameter {
	if x != nil {
		return x.QueryParametersToSet
	}
	return nil
}

func (x *OkHttpResponse) GetQueryParametersToRemove() []string {
	if x != nil {
		return x.QueryParametersToRemove
	}
	return nil
}

// Intended for gRPC and Network Authorization servers “only“.
type CheckResponse struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Status “OK“ allows the request. Any other status indicates the request should be denied, and
	// for HTTP filter, if not overridden by :ref:`denied HTTP response status <envoy_v3_api_field_service.auth.v3.DeniedHttpResponse.status>`
	// Envoy sends “403 Forbidden“ HTTP status code by default.
	Status *Status `protobuf:"bytes,1,opt,name=status,proto3" json:"status,omitempty"`
	// An message that contains HTTP response attributes. This message is
	// used when the authorization service needs to send custom responses to the
	// downstream client or, to modify/add request headers being dispatched to the upstream.
	//
	// Types that are valid to be assigned to HttpResponse:
	//
	//	*CheckResponse_DeniedResponse
	//	*CheckResponse_OkResponse
	HttpResponse isCheckResponse_HttpResponse `protobuf_oneof:"http_response"`
	// Optional response metadata that will be emitted as dynamic metadata to be consumed by the next
	// filter. This metadata lives in a namespace specified by the canonical name of extension filter
	// that requires it:
	//
	// - :ref:`envoy.filters.http.ext_authz <config_http_filters_ext_authz_dynamic_metadata>` for HTTP filter.
	// - :ref:`envoy.filters.network.ext_authz <config_network_filters_ext_authz_dynamic_metadata>` for network filter.
	DynamicMetadata *structpb.Struct `protobuf:"bytes,4,opt,name=dynamic_metadata,json=dynamicMetadata,proto3" json:"dynamic_metadata,omitempty"`
	unknownFields   protoimpl.UnknownFields
	sizeCache       protoimpl.SizeCache
}

func (x *CheckResponse) Reset() {
	*x = CheckResponse{}
	mi := &file_ext_authz_proto_msgTypes[3]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *CheckResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*CheckResponse) ProtoMessage() {}

func (x *CheckResponse) ProtoReflect() protoreflect.Message {
	mi := &file_ext_authz_proto_msgTypes[3]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use CheckResponse.ProtoReflect.Descriptor instead.
func (*CheckResponse) Descriptor() ([]byte, []int) {
	return file_ext_authz_proto_rawDescGZIP(), []int{3}
}

func (x *CheckResponse) GetStatus() *Status {
	if x != nil {
		return x.Status
	}
	return nil
}

func (x *CheckResponse) GetHttpResponse() isCheckResponse_HttpResponse {
	if x != nil {
		return x.HttpResponse
	}
	return nil
}

func (x *CheckResponse) GetDeniedResponse() *DeniedHttpResponse {
	if x != nil {
		if x, ok := x.HttpResponse.(*CheckResponse_DeniedResponse); ok {
			return x.DeniedResponse
		}
	}
	return nil
}

func (x *CheckResponse) GetOkResponse() *OkHttpResponse {
	if x != nil {
		if x, ok := x.HttpResponse.(*CheckResponse_OkResponse); ok {
			return x.OkResponse
		}
	}
	return nil
}

func (x *CheckResponse) GetDynamicMetadata() *structpb.Struct {
	if x != nil {
		return x.DynamicMetadata
	}
	return nil
}

type isCheckResponse_HttpResponse interface {
	isCheckResponse_HttpResponse()
}

type CheckResponse_DeniedResponse struct {
	// Supplies http attributes for a denied response.
	DeniedResponse *DeniedHttpResponse `protobuf:"bytes,2,opt,name=denied_response,json=deniedResponse,proto3,oneof"`
}

type CheckResponse_OkResponse struct {
	// Supplies http attributes for an ok response.
	OkResponse *OkHttpResponse `protobuf:"bytes,3,opt,name=ok_response,json=okResponse,proto3,oneof"`
}

func (*CheckResponse_DeniedResponse) isCheckResponse_HttpResponse() {}

func (*CheckResponse_OkResponse) isCheckResponse_HttpResponse() {}

type Status struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// The status code, which should be an enum value of [google.rpc.Code][google.rpc.Code].
	Code int32 `protobuf:"varint,1,opt,name=code,proto3" json:"code,omitempty"`
	// A developer-facing error message, which should be in English. Any
	// user-facing error message should be localized and sent in the
	// [google.rpc.Status.details][google.rpc.Status.details] field, or localized by the client.
	Message string `protobuf:"bytes,2,opt,name=message,proto3" json:"message,omitempty"`
	// A list of messages that carry the error details.  There is a common set of
	// message types for APIs to use.
	Details       []*anypb.Any `protobuf:"bytes,3,rep,name=details,proto3" json:"details,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *Status) Reset() {
	*x = Status{}
	mi := &file_ext_authz_proto_msgTypes[4]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *Status) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*Status) ProtoMessage() {}

func (x *Status) ProtoReflect() protoreflect.Message {
	mi := &file_ext_authz_proto_msgTypes[4]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use Status.ProtoReflect.Descriptor instead.
func (*Status) Descriptor() ([]byte, []int) {
	return file_ext_authz_proto_rawDescGZIP(), []int{4}
}

func (x *Status) GetCode() int32 {
	if x != nil {
		return x.Code
	}
	return 0
}

func (x *Status) GetMessage() string {
	if x != nil {
		return x.Message
	}
	return ""
}

func (x *Status) GetDetails() []*anypb.Any {
	if x != nil {
		return x.Details
	}
	return nil
}

type AttributeContext struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// The source of a network activity, such as starting a TCP connection.
	// In a multi hop network activity, the source represents the sender of the
	// last hop.
	Source *AttributeContext_Peer `protobuf:"bytes,1,opt,name=source,proto3" json:"source,omitempty"`
	// The destination of a network activity, such as accepting a TCP connection.
	// In a multi hop network activity, the destination represents the receiver of
	// the last hop.
	Destination *AttributeContext_Peer `protobuf:"bytes,2,opt,name=destination,proto3" json:"destination,omitempty"`
	// Represents a network request, such as an HTTP request.
	Request *AttributeContext_Request `protobuf:"bytes,4,opt,name=request,proto3" json:"request,omitempty"`
	// This is analogous to http_request.headers, however these contents will not be sent to the
	// upstream server. Context_extensions provide an extension mechanism for sending additional
	// information to the auth server without modifying the proto definition. It maps to the
	// internal opaque context in the filter chain.
	ContextExtensions map[string]string `protobuf:"bytes,10,rep,name=context_extensions,json=contextExtensions,proto3" json:"context_extensions,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"`
	// Dynamic metadata associated with the request.
	MetadataContext *Metadata `protobuf:"bytes,11,opt,name=metadata_context,json=metadataContext,proto3" json:"metadata_context,omitempty"`
	// TLS session details of the underlying connection.
	// This is not populated by default and will be populated only if the ext_authz filter has
	// been specifically configured to include this information.
	// For HTTP ext_authz, that requires :ref:`include_tls_session <config_http_filters_ext_authz>`
	// to be set to true.
	// For network ext_authz, that requires :ref:`include_tls_session <config_network_filters_ext_authz>`
	// to be set to true.
	TlsSession    *AttributeContext_TLSSession `protobuf:"bytes,12,opt,name=tls_session,json=tlsSession,proto3" json:"tls_session,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *AttributeContext) Reset() {
	*x = AttributeContext{}
	mi := &file_ext_authz_proto_msgTypes[5]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *AttributeContext) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*AttributeContext) ProtoMessage() {}

func (x *AttributeContext) ProtoReflect() protoreflect.Message {
	mi := &file_ext_authz_proto_msgTypes[5]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use AttributeContext.ProtoReflect.Descriptor instead.
func (*AttributeContext) Descriptor() ([]byte, []int) {
	return file_ext_authz_proto_rawDescGZIP(), []int{5}
}

func (x *AttributeContext) GetSource() *AttributeContext_Peer {
	if x != nil {
		return x.Source
	}
	return nil
}

func (x *AttributeContext) GetDestination() *AttributeContext_Peer {
	if x != nil {
		return x.Destination
	}
	return nil
}

func (x *AttributeContext) GetRequest() *AttributeContext_Request {
	if x != nil {
		return x.Request
	}
	return nil
}

func (x *AttributeContext) GetContextExtensions() map[string]string {
	if x != nil {
		return x.ContextExtensions
	}
	return nil
}

func (x *AttributeContext) GetMetadataContext() *Metadata {
	if x != nil {
		return x.MetadataContext
	}
	return nil
}

func (x *AttributeContext) GetTlsSession() *AttributeContext_TLSSession {
	if x != nil {
		return x.TlsSession
	}
	return nil
}

type HttpStatus struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Supplies HTTP response code.
	Code          StatusCode `protobuf:"varint,1,opt,name=code,proto3,enum=envoy.service.auth.v3.StatusCode" json:"code,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *HttpStatus) Reset() {
	*x = HttpStatus{}
	mi := &file_ext_authz_proto_msgTypes[6]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *HttpStatus) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*HttpStatus) ProtoMessage() {}

func (x *HttpStatus) ProtoReflect() protoreflect.Message {
	mi := &file_ext_authz_proto_msgTypes[6]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use HttpStatus.ProtoReflect.Descriptor instead.
func (*HttpStatus) Descriptor() ([]byte, []int) {
	return file_ext_authz_proto_rawDescGZIP(), []int{6}
}

func (x *HttpStatus) GetCode() StatusCode {
	if x != nil {
		return x.Code
	}
	return StatusCode_Empty
}

// Header name/value pair plus option to control append behavior.
type HeaderValueOption struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Header name/value pair that this option applies to.
	Header *HeaderValue `protobuf:"bytes,1,opt,name=header,proto3" json:"header,omitempty"`
	// Should the value be appended? If true (default), the value is appended to
	// existing values.
	// This field is deprecated and please use append_action as replacement.
	Append *wrapperspb.BoolValue `protobuf:"bytes,2,opt,name=append,proto3" json:"append,omitempty"`
	// Describes the action taken to append/overwrite the given value for an existing header
	// or to only add this header if it's absent.
	// Value defaults to APPEND_IF_EXISTS_OR_ADD.
	AppendAction  HeaderValueOption_HeaderAppendAction `protobuf:"varint,3,opt,name=append_action,json=appendAction,proto3,enum=envoy.service.auth.v3.HeaderValueOption_HeaderAppendAction" json:"append_action,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *HeaderValueOption) Reset() {
	*x = HeaderValueOption{}
	mi := &file_ext_authz_proto_msgTypes[7]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *HeaderValueOption) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*HeaderValueOption) ProtoMessage() {}

func (x *HeaderValueOption) ProtoReflect() protoreflect.Message {
	mi := &file_ext_authz_proto_msgTypes[7]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use HeaderValueOption.ProtoReflect.Descriptor instead.
func (*HeaderValueOption) Descriptor() ([]byte, []int) {
	return file_ext_authz_proto_rawDescGZIP(), []int{7}
}

func (x *HeaderValueOption) GetHeader() *HeaderValue {
	if x != nil {
		return x.Header
	}
	return nil
}

func (x *HeaderValueOption) GetAppend() *wrapperspb.BoolValue {
	if x != nil {
		return x.Append
	}
	return nil
}

func (x *HeaderValueOption) GetAppendAction() HeaderValueOption_HeaderAppendAction {
	if x != nil {
		return x.AppendAction
	}
	return HeaderValueOption_APPEND_IF_EXISTS_OR_ADD
}

// Header name/value pair.
type HeaderValue struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Header name.
	Key   string `protobuf:"bytes,1,opt,name=key,proto3" json:"key,omitempty"`
	Value string `protobuf:"bytes,2,opt,name=value,proto3" json:"value,omitempty"`
	// Header value.
	//
	// The same :ref:`format specifier <config_access_log_format>` as used for
	// :ref:`HTTP access logging <config_access_log>` applies here, however
	// unknown header values are replaced with the empty string instead of “-“.
	//
	//	string value = 2;
	RawValue      []byte `protobuf:"bytes,3,opt,name=raw_value,json=rawValue,proto3" json:"raw_value,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *HeaderValue) Reset() {
	*x = HeaderValue{}
	mi := &file_ext_authz_proto_msgTypes[8]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *HeaderValue) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*HeaderValue) ProtoMessage() {}

func (x *HeaderValue) ProtoReflect() protoreflect.Message {
	mi := &file_ext_authz_proto_msgTypes[8]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use HeaderValue.ProtoReflect.Descriptor instead.
func (*HeaderValue) Descriptor() ([]byte, []int) {
	return file_ext_authz_proto_rawDescGZIP(), []int{8}
}

func (x *HeaderValue) GetKey() string {
	if x != nil {
		return x.Key
	}
	return ""
}

func (x *HeaderValue) GetValue() string {
	if x != nil {
		return x.Value
	}
	return ""
}

func (x *HeaderValue) GetRawValue() []byte {
	if x != nil {
		return x.RawValue
	}
	return nil
}

type QueryParameter struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// The key of the query parameter. Case sensitive.
	Key string `protobuf:"bytes,1,opt,name=key,proto3" json:"key,omitempty"`
	// The value of the query parameter.
	Value         string `protobuf:"bytes,2,opt,name=value,proto3" json:"value,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *QueryParameter) Reset() {
	*x = QueryParameter{}
	mi := &file_ext_authz_proto_msgTypes[9]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *QueryParameter) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*QueryParameter) ProtoMessage() {}

func (x *QueryParameter) ProtoReflect() protoreflect.Message {
	mi := &file_ext_authz_proto_msgTypes[9]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use QueryParameter.ProtoReflect.Descriptor instead.
func (*QueryParameter) Descriptor() ([]byte, []int) {
	return file_ext_authz_proto_rawDescGZIP(), []int{9}
}

func (x *QueryParameter) GetKey() string {
	if x != nil {
		return x.Key
	}
	return ""
}

func (x *QueryParameter) GetValue() string {
	if x != nil {
		return x.Value
	}
	return ""
}

type Address struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Types that are valid to be assigned to Address:
	//
	//	*Address_SocketAddress
	Address       isAddress_Address `protobuf_oneof:"address"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *Address) Reset() {
	*x = Address{}
	mi := &file_ext_authz_proto_msgTypes[10]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *Address) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*Address) ProtoMessage() {}

func (x *Address) ProtoReflect() protoreflect.Message {
	mi := &file_ext_authz_proto_msgTypes[10]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use Address.ProtoReflect.Descriptor instead.
func (*Address) Descriptor() ([]byte, []int) {
	return file_ext_authz_proto_rawDescGZIP(), []int{10}
}

func (x *Address) GetAddress() isAddress_Address {
	if x != nil {
		return x.Address
	}
	return nil
}

func (x *Address) GetSocketAddress() *SocketAddress {
	if x != nil {
		if x, ok := x.Address.(*Address_SocketAddress); ok {
			return x.SocketAddress
		}
	}
	return nil
}

type isAddress_Address interface {
	isAddress_Address()
}

type Address_SocketAddress struct {
	SocketAddress *SocketAddress `protobuf:"bytes,1,opt,name=socket_address,json=socketAddress,proto3,oneof"`
}

func (*Address_SocketAddress) isAddress_Address() {}

type SocketAddress struct {
	state    protoimpl.MessageState `protogen:"open.v1"`
	Protocol SocketAddress_Protocol `protobuf:"varint,1,opt,name=protocol,proto3,enum=envoy.service.auth.v3.SocketAddress_Protocol" json:"protocol,omitempty"`
	// The address for this socket. :ref:`Listeners <config_listeners>` will bind
	// to the address. An empty address is not allowed. Specify “0.0.0.0“ or “::“
	// to bind to any address. [#comment:TODO(zuercher) reinstate when implemented:
	// It is possible to distinguish a Listener address via the prefix/suffix matching
	// in :ref:`FilterChainMatch <envoy_v3_api_msg_config.listener.v3.FilterChainMatch>`.] When used
	// within an upstream :ref:`BindConfig <envoy_v3_api_msg_config.core.v3.BindConfig>`, the address
	// controls the source address of outbound connections. For :ref:`clusters
	// <envoy_v3_api_msg_config.cluster.v3.Cluster>`, the cluster type determines whether the
	// address must be an IP (“STATIC“ or “EDS“ clusters) or a hostname resolved by DNS
	// (“STRICT_DNS“ or “LOGICAL_DNS“ clusters). Address resolution can be customized
	// via :ref:`resolver_name <envoy_v3_api_field_config.core.v3.SocketAddress.resolver_name>`.
	Address string `protobuf:"bytes,2,opt,name=address,proto3" json:"address,omitempty"`
	// Types that are valid to be assigned to PortSpecifier:
	//
	//	*SocketAddress_PortValue
	//	*SocketAddress_NamedPort
	PortSpecifier isSocketAddress_PortSpecifier `protobuf_oneof:"port_specifier"`
	// The name of the custom resolver. This must have been registered with Envoy. If
	// this is empty, a context dependent default applies. If the address is a concrete
	// IP address, no resolution will occur. If address is a hostname this
	// should be set for resolution other than DNS. Specifying a custom resolver with
	// “STRICT_DNS“ or “LOGICAL_DNS“ will generate an error at runtime.
	ResolverName string `protobuf:"bytes,5,opt,name=resolver_name,json=resolverName,proto3" json:"resolver_name,omitempty"`
	// When binding to an IPv6 address above, this enables `IPv4 compatibility
	// <https://tools.ietf.org/html/rfc3493#page-11>`_. Binding to “::“ will
	// allow both IPv4 and IPv6 connections, with peer IPv4 addresses mapped into
	// IPv6 space as “::FFFF:<IPv4-address>“.
	Ipv4Compat bool `protobuf:"varint,6,opt,name=ipv4_compat,json=ipv4Compat,proto3" json:"ipv4_compat,omitempty"`
	// Filepath that specifies the Linux network namespace this socket will be created in (see “man 7
	// network_namespaces“). If this field is set, Envoy will create the socket in the specified
	// network namespace.
	//
	// .. note::
	//
	//	Setting this parameter requires Envoy to run with the ``CAP_NET_ADMIN`` capability.
	//
	// .. note::
	//
	//	Currently only used for Listener sockets.
	//
	// .. attention::
	//
	//	Network namespaces are only configurable on Linux. Otherwise, this field has no effect.
	NetworkNamespaceFilepath string `protobuf:"bytes,7,opt,name=network_namespace_filepath,json=networkNamespaceFilepath,proto3" json:"network_namespace_filepath,omitempty"`
	unknownFields            protoimpl.UnknownFields
	sizeCache                protoimpl.SizeCache
}

func (x *SocketAddress) Reset() {
	*x = SocketAddress{}
	mi := &file_ext_authz_proto_msgTypes[11]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *SocketAddress) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*SocketAddress) ProtoMessage() {}

func (x *SocketAddress) ProtoReflect() protoreflect.Message {
	mi := &file_ext_authz_proto_msgTypes[11]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use SocketAddress.ProtoReflect.Descriptor instead.
func (*SocketAddress) Descriptor() ([]byte, []int) {
	return file_ext_authz_proto_rawDescGZIP(), []int{11}
}

func (x *SocketAddress) GetProtocol() SocketAddress_Protocol {
	if x != nil {
		return x.Protocol
	}
	return SocketAddress_TCP
}

func (x *SocketAddress) GetAddress() string {
	if x != nil {
		return x.Address
	}
	return ""
}

func (x *SocketAddress) GetPortSpecifier() isSocketAddress_PortSpecifier {
	if x != nil {
		return x.PortSpecifier
	}
	return nil
}

func (x *SocketAddress) GetPortValue() uint32 {
	if x != nil {
		if x, ok := x.PortSpecifier.(*SocketAddress_PortValue); ok {
			return x.PortValue
		}
	}
	return 0
}

func (x *SocketAddress) GetNamedPort() string {
	if x != nil {
		if x, ok := x.PortSpecifier.(*SocketAddress_NamedPort); ok {
			return x.NamedPort
		}
	}
	return ""
}

func (x *SocketAddress) GetResolverName() string {
	if x != nil {
		return x.ResolverName
	}
	return ""
}

func (x *SocketAddress) GetIpv4Compat() bool {
	if x != nil {
		return x.Ipv4Compat
	}
	return false
}

func (x *SocketAddress) GetNetworkNamespaceFilepath() string {
	if x != nil {
		return x.NetworkNamespaceFilepath
	}
	return ""
}

type isSocketAddress_PortSpecifier interface {
	isSocketAddress_PortSpecifier()
}

type SocketAddress_PortValue struct {
	PortValue uint32 `protobuf:"varint,3,opt,name=port_value,json=portValue,proto3,oneof"`
}

type SocketAddress_NamedPort struct {
	// This is only valid if :ref:`resolver_name
	// <envoy_v3_api_field_config.core.v3.SocketAddress.resolver_name>` is specified below and the
	// named resolver is capable of named port resolution.
	NamedPort string `protobuf:"bytes,4,opt,name=named_port,json=namedPort,proto3,oneof"`
}

func (*SocketAddress_PortValue) isSocketAddress_PortSpecifier() {}

func (*SocketAddress_NamedPort) isSocketAddress_PortSpecifier() {}

type Metadata struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Key is the reverse DNS filter name, e.g. com.acme.widget. The “envoy.*“
	// namespace is reserved for Envoy's built-in filters.
	// If both “filter_metadata“ and
	// :ref:`typed_filter_metadata <envoy_v3_api_field_config.core.v3.Metadata.typed_filter_metadata>`
	// fields are present in the metadata with same keys,
	// only “typed_filter_metadata“ field will be parsed.
	FilterMetadata map[string]*structpb.Struct `protobuf:"bytes,1,rep,name=filter_metadata,json=filterMetadata,proto3" json:"filter_metadata,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"`
	unknownFields  protoimpl.UnknownFields
	sizeCache      protoimpl.SizeCache
}

func (x *Metadata) Reset() {
	*x = Metadata{}
	mi := &file_ext_authz_proto_msgTypes[12]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *Metadata) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*Metadata) ProtoMessage() {}

func (x *Metadata) ProtoReflect() protoreflect.Message {
	mi := &file_ext_authz_proto_msgTypes[12]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use Metadata.ProtoReflect.Descriptor instead.
func (*Metadata) Descriptor() ([]byte, []int) {
	return file_ext_authz_proto_rawDescGZIP(), []int{12}
}

func (x *Metadata) GetFilterMetadata() map[string]*structpb.Struct {
	if x != nil {
		return x.FilterMetadata
	}
	return nil
}

// This message defines attributes for a node that handles a network request.
// The node can be either a service or an application that sends, forwards,
// or receives the request. Service peers should fill in the “service“,
// “principal“, and “labels“ as appropriate.
// [#next-free-field: 6]
type AttributeContext_Peer struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// The address of the peer, this is typically the IP address.
	// It can also be UDS path, or others.
	Address *Address `protobuf:"bytes,1,opt,name=address,proto3" json:"address,omitempty"`
	// The canonical service name of the peer.
	// It should be set to :ref:`the HTTP x-envoy-downstream-service-cluster
	// <config_http_conn_man_headers_downstream-service-cluster>`
	// If a more trusted source of the service name is available through mTLS/secure naming, it
	// should be used.
	Service string `protobuf:"bytes,2,opt,name=service,proto3" json:"service,omitempty"`
	// The labels associated with the peer.
	// These could be pod labels for Kubernetes or tags for VMs.
	// The source of the labels could be an X.509 certificate or other configuration.
	Labels map[string]string `protobuf:"bytes,3,rep,name=labels,proto3" json:"labels,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"`
	// The authenticated identity of this peer.
	// For example, the identity associated with the workload such as a service account.
	// If an X.509 certificate is used to assert the identity this field should be sourced from
	// “URI Subject Alternative Names“, “DNS Subject Alternate Names“ or “Subject“ in that order.
	// The primary identity should be the principal. The principal format is issuer specific.
	//
	// Examples:
	//
	// - SPIFFE format is “spiffe://trust-domain/path“.
	// - Google account format is “https://accounts.google.com/{userid}“.
	Principal string `protobuf:"bytes,4,opt,name=principal,proto3" json:"principal,omitempty"`
	// The X.509 certificate used to authenticate the identify of this peer.
	// When present, the certificate contents are encoded in URL and PEM format.
	Certificate   string `protobuf:"bytes,5,opt,name=certificate,proto3" json:"certificate,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *AttributeContext_Peer) Reset() {
	*x = AttributeContext_Peer{}
	mi := &file_ext_authz_proto_msgTypes[13]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *AttributeContext_Peer) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*AttributeContext_Peer) ProtoMessage() {}

func (x *AttributeContext_Peer) ProtoReflect() protoreflect.Message {
	mi := &file_ext_authz_proto_msgTypes[13]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use AttributeContext_Peer.ProtoReflect.Descriptor instead.
func (*AttributeContext_Peer) Descriptor() ([]byte, []int) {
	return file_ext_authz_proto_rawDescGZIP(), []int{5, 0}
}

func (x *AttributeContext_Peer) GetAddress() *Address {
	if x != nil {
		return x.Address
	}
	return nil
}

func (x *AttributeContext_Peer) GetService() string {
	if x != nil {
		return x.Service
	}
	return ""
}

func (x *AttributeContext_Peer) GetLabels() map[string]string {
	if x != nil {
		return x.Labels
	}
	return nil
}

func (x *AttributeContext_Peer) GetPrincipal() string {
	if x != nil {
		return x.Principal
	}
	return ""
}

func (x *AttributeContext_Peer) GetCertificate() string {
	if x != nil {
		return x.Certificate
	}
	return ""
}

// Represents a network request, such as an HTTP request.
type AttributeContext_Request struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// The timestamp when the proxy receives the first byte of the request.
	Time *timestamppb.Timestamp `protobuf:"bytes,1,opt,name=time,proto3" json:"time,omitempty"`
	// Represents an HTTP request or an HTTP-like request.
	Http          *AttributeContext_HttpRequest `protobuf:"bytes,2,opt,name=http,proto3" json:"http,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *AttributeContext_Request) Reset() {
	*x = AttributeContext_Request{}
	mi := &file_ext_authz_proto_msgTypes[14]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *AttributeContext_Request) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*AttributeContext_Request) ProtoMessage() {}

func (x *AttributeContext_Request) ProtoReflect() protoreflect.Message {
	mi := &file_ext_authz_proto_msgTypes[14]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use AttributeContext_Request.ProtoReflect.Descriptor instead.
func (*AttributeContext_Request) Descriptor() ([]byte, []int) {
	return file_ext_authz_proto_rawDescGZIP(), []int{5, 1}
}

func (x *AttributeContext_Request) GetTime() *timestamppb.Timestamp {
	if x != nil {
		return x.Time
	}
	return nil
}

func (x *AttributeContext_Request) GetHttp() *AttributeContext_HttpRequest {
	if x != nil {
		return x.Http
	}
	return nil
}

// This message defines attributes for an HTTP request.
// HTTP/1.x, HTTP/2, gRPC are all considered as HTTP requests.
// [#next-free-field: 14]
type AttributeContext_HttpRequest struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// The unique ID for a request, which can be propagated to downstream
	// systems. The ID should have low probability of collision
	// within a single day for a specific service.
	// For HTTP requests, it should be X-Request-ID or equivalent.
	Id string `protobuf:"bytes,1,opt,name=id,proto3" json:"id,omitempty"`
	// The HTTP request method, such as “GET“, “POST“.
	Method string `protobuf:"bytes,2,opt,name=method,proto3" json:"method,omitempty"`
	// The HTTP request headers. If multiple headers share the same key, they
	// must be merged according to the HTTP spec. All header keys must be
	// lower-cased, because HTTP header keys are case-insensitive.
	// Header value is encoded as UTF-8 string. Non-UTF-8 characters will be replaced by "!".
	// This field will not be set if
	// :ref:`encode_raw_headers <envoy_v3_api_field_extensions.filters.http.ext_authz.v3.ExtAuthz.encode_raw_headers>`
	// is set to true.
	Headers map[string]string `protobuf:"bytes,3,rep,name=headers,proto3" json:"headers,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"`
	// The request target, as it appears in the first line of the HTTP request. This includes
	// the URL path and query-string. No decoding is performed.
	Path string `protobuf:"bytes,4,opt,name=path,proto3" json:"path,omitempty"`
	// The HTTP request “Host“ or “:authority“ header value.
	Host string `protobuf:"bytes,5,opt,name=host,proto3" json:"host,omitempty"`
	// The HTTP URL scheme, such as “http“ and “https“.
	Scheme string `protobuf:"bytes,6,opt,name=scheme,proto3" json:"scheme,omitempty"`
	// This field is always empty, and exists for compatibility reasons. The HTTP URL query is
	// included in “path“ field.
	Query string `protobuf:"bytes,7,opt,name=query,proto3" json:"query,omitempty"`
	// This field is always empty, and exists for compatibility reasons. The URL fragment is
	// not submitted as part of HTTP requests; it is unknowable.
	Fragment string `protobuf:"bytes,8,opt,name=fragment,proto3" json:"fragment,omitempty"`
	// The HTTP request size in bytes. If unknown, it must be -1.
	Size int64 `protobuf:"varint,9,opt,name=size,proto3" json:"size,omitempty"`
	// The network protocol used with the request, such as "HTTP/1.0", "HTTP/1.1", or "HTTP/2".
	//
	// See :repo:`headers.h:ProtocolStrings <source/common/http/headers.h>` for a list of all
	// possible values.
	Protocol string `protobuf:"bytes,10,opt,name=protocol,proto3" json:"protocol,omitempty"`
	// The HTTP request body.
	Body string `protobuf:"bytes,11,opt,name=body,proto3" json:"body,omitempty"`
	// The HTTP request body in bytes. This is used instead of
	// :ref:`body <envoy_v3_api_field_service.auth.v3.AttributeContext.HttpRequest.body>` when
	// :ref:`pack_as_bytes <envoy_v3_api_field_extensions.filters.http.ext_authz.v3.BufferSettings.pack_as_bytes>`
	// is set to true.
	RawBody       []byte `protobuf:"bytes,12,opt,name=raw_body,json=rawBody,proto3" json:"raw_body,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *AttributeContext_HttpRequest) Reset() {
	*x = AttributeContext_HttpRequest{}
	mi := &file_ext_authz_proto_msgTypes[15]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *AttributeContext_HttpRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*AttributeContext_HttpRequest) ProtoMessage() {}

func (x *AttributeContext_HttpRequest) ProtoReflect() protoreflect.Message {
	mi := &file_ext_authz_proto_msgTypes[15]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use AttributeContext_HttpRequest.ProtoReflect.Descriptor instead.
func (*AttributeContext_HttpRequest) Descriptor() ([]byte, []int) {
	return file_ext_authz_proto_rawDescGZIP(), []int{5, 2}
}

func (x *AttributeContext_HttpRequest) GetId() string {
	if x != nil {
		return x.Id
	}
	return ""
}

func (x *AttributeContext_HttpRequest) GetMethod() string {
	if x != nil {
		return x.Method
	}
	return ""
}

func (x *AttributeContext_HttpRequest) GetHeaders() map[string]string {
	if x != nil {
		return x.Headers
	}
	return nil
}

func (x *AttributeContext_HttpRequest) GetPath() string {
	if x != nil {
		return x.Path
	}
	return ""
}

func (x *AttributeContext_HttpRequest) GetHost() string {
	if x != nil {
		return x.Host
	}
	return ""
}

func (x *AttributeContext_HttpRequest) GetScheme() string {
	if x != nil {
		return x.Scheme
	}
	return ""
}

func (x *AttributeContext_HttpRequest) GetQuery() string {
	if x != nil {
		return x.Query
	}
	return ""
}

func (x *AttributeContext_HttpRequest) GetFragment() string {
	if x != nil {
		return x.Fragment
	}
	return ""
}

func (x *AttributeContext_HttpRequest) GetSize() int64 {
	if x != nil {
		return x.Size
	}
	return 0
}

func (x *AttributeContext_HttpRequest) GetProtocol() string {
	if x != nil {
		return x.Protocol
	}
	return ""
}

func (x *AttributeContext_HttpRequest) GetBody() string {
	if x != nil {
		return x.Body
	}
	return ""
}

func (x *AttributeContext_HttpRequest) GetRawBody() []byte {
	if x != nil {
		return x.RawBody
	}
	return nil
}

// This message defines attributes for the underlying TLS session.
type AttributeContext_TLSSession struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// SNI used for TLS session.
	Sni           string `protobuf:"bytes,1,opt,name=sni,proto3" json:"sni,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *AttributeContext_TLSSession) Reset() {
	*x = AttributeContext_TLSSession{}
	mi := &file_ext_authz_proto_msgTypes[16]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *AttributeContext_TLSSession) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*AttributeContext_TLSSession) ProtoMessage() {}

func (x *AttributeContext_TLSSession) ProtoReflect() protoreflect.Message {
	mi := &file_ext_authz_proto_msgTypes[16]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use AttributeContext_TLSSession.ProtoReflect.Descriptor instead.
func (*AttributeContext_TLSSession) Descriptor() ([]byte, []int) {
	return file_ext_authz_proto_rawDescGZIP(), []int{5, 3}
}

func (x *AttributeContext_TLSSession) GetSni() string {
	if x != nil {
		return x.Sni
	}
	return ""
}

var File_ext_authz_proto protoreflect.FileDescriptor

const file_ext_authz_proto_rawDesc = "" +
	"\n" +
	"\x0fext_authz.proto\x12\x15envoy.service.auth.v3\x1a\x19google/protobuf/any.proto\x1a\x1egoogle/protobuf/wrappers.proto\x1a\x1cgoogle/protobuf/struct.proto\x1a\x1egoogle/protobuf/duration.proto\x1a\x1fgoogle/protobuf/timestamp.proto\"W\n" +
	"\fCheckRequest\x12G\n" +
	"\n" +
	"attributes\x18\x01 \x01(\v2'.envoy.service.auth.v3.AttributeContextR\n" +
	"attributes\"\xa7\x01\n" +
	"\x12DeniedHttpResponse\x129\n" +
	"\x06status\x18\x01 \x01(\v2!.envoy.service.auth.v3.HttpStatusR\x06status\x12B\n" +
	"\aheaders\x18\x02 \x03(\v2(.envoy.service.auth.v3.HeaderValueOptionR\aheaders\x12\x12\n" +
	"\x04body\x18\x03 \x01(\tR\x04body\"\xc4\x03\n" +
	"\x0eOkHttpResponse\x12B\n" +
	"\aheaders\x18\x02 \x03(\v2(.envoy.service.auth.v3.HeaderValueOptionR\aheaders\x12*\n" +
	"\x11headers_to_remove\x18\x05 \x03(\tR\x0fheadersToRemove\x12F\n" +
	"\x10dynamic_metadata\x18\x03 \x01(\v2\x17.google.protobuf.StructB\x02\x18\x01R\x0fdynamicMetadata\x12_\n" +
	"\x17response_headers_to_add\x18\x06 \x03(\v2(.envoy.service.auth.v3.HeaderValueOptionR\x14responseHeadersToAdd\x12\\\n" +
	"\x17query_parameters_to_set\x18\a \x03(\v2%.envoy.service.auth.v3.QueryParameterR\x14queryParametersToSet\x12;\n" +
	"\x1aquery_parameters_to_remove\x18\b \x03(\tR\x17queryParametersToRemove\"\xbb\x02\n" +
	"\rCheckResponse\x125\n" +
	"\x06status\x18\x01 \x01(\v2\x1d.envoy.service.auth.v3.StatusR\x06status\x12T\n" +
	"\x0fdenied_response\x18\x02 \x01(\v2).envoy.service.auth.v3.DeniedHttpResponseH\x00R\x0edeniedResponse\x12H\n" +
	"\vok_response\x18\x03 \x01(\v2%.envoy.service.auth.v3.OkHttpResponseH\x00R\n" +
	"okResponse\x12B\n" +
	"\x10dynamic_metadata\x18\x04 \x01(\v2\x17.google.protobuf.StructR\x0fdynamicMetadataB\x0f\n" +
	"\rhttp_response\"f\n" +
	"\x06Status\x12\x12\n" +
	"\x04code\x18\x01 \x01(\x05R\x04code\x12\x18\n" +
	"\amessage\x18\x02 \x01(\tR\amessage\x12.\n" +
	"\adetails\x18\x03 \x03(\v2\x14.google.protobuf.AnyR\adetails\"\xb9\v\n" +
	"\x10AttributeContext\x12D\n" +
	"\x06source\x18\x01 \x01(\v2,.envoy.service.auth.v3.AttributeContext.PeerR\x06source\x12N\n" +
	"\vdestination\x18\x02 \x01(\v2,.envoy.service.auth.v3.AttributeContext.PeerR\vdestination\x12I\n" +
	"\arequest\x18\x04 \x01(\v2/.envoy.service.auth.v3.AttributeContext.RequestR\arequest\x12m\n" +
	"\x12context_extensions\x18\n" +
	" \x03(\v2>.envoy.service.auth.v3.AttributeContext.ContextExtensionsEntryR\x11contextExtensions\x12J\n" +
	"\x10metadata_context\x18\v \x01(\v2\x1f.envoy.service.auth.v3.MetadataR\x0fmetadataContext\x12S\n" +
	"\vtls_session\x18\f \x01(\v22.envoy.service.auth.v3.AttributeContext.TLSSessionR\n" +
	"tlsSession\x1a\xa7\x02\n" +
	"\x04Peer\x128\n" +
	"\aaddress\x18\x01 \x01(\v2\x1e.envoy.service.auth.v3.AddressR\aaddress\x12\x18\n" +
	"\aservice\x18\x02 \x01(\tR\aservice\x12P\n" +
	"\x06labels\x18\x03 \x03(\v28.envoy.service.auth.v3.AttributeContext.Peer.LabelsEntryR\x06labels\x12\x1c\n" +
	"\tprincipal\x18\x04 \x01(\tR\tprincipal\x12 \n" +
	"\vcertificate\x18\x05 \x01(\tR\vcertificate\x1a9\n" +
	"\vLabelsEntry\x12\x10\n" +
	"\x03key\x18\x01 \x01(\tR\x03key\x12\x14\n" +
	"\x05value\x18\x02 \x01(\tR\x05value:\x028\x01\x1a\x82\x01\n" +
	"\aRequest\x12.\n" +
	"\x04time\x18\x01 \x01(\v2\x1a.google.protobuf.TimestampR\x04time\x12G\n" +
	"\x04http\x18\x02 \x01(\v23.envoy.service.auth.v3.AttributeContext.HttpRequestR\x04http\x1a\x9e\x03\n" +
	"\vHttpRequest\x12\x0e\n" +
	"\x02id\x18\x01 \x01(\tR\x02id\x12\x16\n" +
	"\x06method\x18\x02 \x01(\tR\x06method\x12Z\n" +
	"\aheaders\x18\x03 \x03(\v2@.envoy.service.auth.v3.AttributeContext.HttpRequest.HeadersEntryR\aheaders\x12\x12\n" +
	"\x04path\x18\x04 \x01(\tR\x04path\x12\x12\n" +
	"\x04host\x18\x05 \x01(\tR\x04host\x12\x16\n" +
	"\x06scheme\x18\x06 \x01(\tR\x06scheme\x12\x14\n" +
	"\x05query\x18\a \x01(\tR\x05query\x12\x1a\n" +
	"\bfragment\x18\b \x01(\tR\bfragment\x12\x12\n" +
	"\x04size\x18\t \x01(\x03R\x04size\x12\x1a\n" +
	"\bprotocol\x18\n" +
	" \x01(\tR\bprotocol\x12\x12\n" +
	"\x04body\x18\v \x01(\tR\x04body\x12\x19\n" +
	"\braw_body\x18\f \x01(\fR\arawBody\x1a:\n" +
	"\fHeadersEntry\x12\x10\n" +
	"\x03key\x18\x01 \x01(\tR\x03key\x12\x14\n" +
	"\x05value\x18\x02 \x01(\tR\x05value:\x028\x01\x1a\x1e\n" +
	"\n" +
	"TLSSession\x12\x10\n" +
	"\x03sni\x18\x01 \x01(\tR\x03sni\x1aD\n" +
	"\x16ContextExtensionsEntry\x12\x10\n" +
	"\x03key\x18\x01 \x01(\tR\x03key\x12\x14\n" +
	"\x05value\x18\x02 \x01(\tR\x05value:\x028\x01\"C\n" +
	"\n" +
	"HttpStatus\x125\n" +
	"\x04code\x18\x01 \x01(\x0e2!.envoy.service.auth.v3.StatusCodeR\x04code\"\xe4\x02\n" +
	"\x11HeaderValueOption\x12:\n" +
	"\x06header\x18\x01 \x01(\v2\".envoy.service.auth.v3.HeaderValueR\x06header\x122\n" +
	"\x06append\x18\x02 \x01(\v2\x1a.google.protobuf.BoolValueR\x06append\x12`\n" +
	"\rappend_action\x18\x03 \x01(\x0e2;.envoy.service.auth.v3.HeaderValueOption.HeaderAppendActionR\fappendAction\"}\n" +
	"\x12HeaderAppendAction\x12\x1b\n" +
	"\x17APPEND_IF_EXISTS_OR_ADD\x10\x00\x12\x11\n" +
	"\rADD_IF_ABSENT\x10\x01\x12\x1e\n" +
	"\x1aOVERWRITE_IF_EXISTS_OR_ADD\x10\x02\x12\x17\n" +
	"\x13OVERWRITE_IF_EXISTS\x10\x03\"R\n" +
	"\vHeaderValue\x12\x10\n" +
	"\x03key\x18\x01 \x01(\tR\x03key\x12\x14\n" +
	"\x05value\x18\x02 \x01(\tR\x05value\x12\x1b\n" +
	"\traw_value\x18\x03 \x01(\fR\brawValue\"8\n" +
	"\x0eQueryParameter\x12\x10\n" +
	"\x03key\x18\x01 \x01(\tR\x03key\x12\x14\n" +
	"\x05value\x18\x02 \x01(\tR\x05value\"c\n" +
	"\aAddress\x12M\n" +
	"\x0esocket_address\x18\x01 \x01(\v2$.envoy.service.auth.v3.SocketAddressH\x00R\rsocketAddressB\t\n" +
	"\aaddress\"\xea\x02\n" +
	"\rSocketAddress\x12I\n" +
	"\bprotocol\x18\x01 \x01(\x0e2-.envoy.service.auth.v3.SocketAddress.ProtocolR\bprotocol\x12\x18\n" +
	"\aaddress\x18\x02 \x01(\tR\aaddress\x12\x1f\n" +
	"\n" +
	"port_value\x18\x03 \x01(\rH\x00R\tportValue\x12\x1f\n" +
	"\n" +
	"named_port\x18\x04 \x01(\tH\x00R\tnamedPort\x12#\n" +
	"\rresolver_name\x18\x05 \x01(\tR\fresolverName\x12\x1f\n" +
	"\vipv4_compat\x18\x06 \x01(\bR\n" +
	"ipv4Compat\x12<\n" +
	"\x1anetwork_namespace_filepath\x18\a \x01(\tR\x18networkNamespaceFilepath\"\x1c\n" +
	"\bProtocol\x12\a\n" +
	"\x03TCP\x10\x00\x12\a\n" +
	"\x03UDP\x10\x01B\x10\n" +
	"\x0eport_specifier\"\xc4\x01\n" +
	"\bMetadata\x12\\\n" +
	"\x0ffilter_metadata\x18\x01 \x03(\v23.envoy.service.auth.v3.Metadata.FilterMetadataEntryR\x0efilterMetadata\x1aZ\n" +
	"\x13FilterMetadataEntry\x12\x10\n" +
	"\x03key\x18\x01 \x01(\tR\x03key\x12-\n" +
	"\x05value\x18\x02 \x01(\v2\x17.google.protobuf.StructR\x05value:\x028\x01*\xb5\t\n" +
	"\n" +
	"StatusCode\x12\t\n" +
	"\x05Empty\x10\x00\x12\f\n" +
	"\bContinue\x10d\x12\a\n" +
	"\x02OK\x10\xc8\x01\x12\f\n" +
	"\aCreated\x10\xc9\x01\x12\r\n" +
	"\bAccepted\x10\xca\x01\x12 \n" +
	"\x1bNonAuthoritativeInformation\x10\xcb\x01\x12\x0e\n" +
	"\tNoContent\x10\xcc\x01\x12\x11\n" +
	"\fResetContent\x10\xcd\x01\x12\x13\n" +
	"\x0ePartialContent\x10\xce\x01\x12\x10\n" +
	"\vMultiStatus\x10\xcf\x01\x12\x14\n" +
	"\x0fAlreadyReported\x10\xd0\x01\x12\v\n" +
	"\x06IMUsed\x10\xe2\x01\x12\x14\n" +
	"\x0fMultipleChoices\x10\xac\x02\x12\x15\n" +
	"\x10MovedPermanently\x10\xad\x02\x12\n" +
	"\n" +
	"\x05Found\x10\xae\x02\x12\r\n" +
	"\bSeeOther\x10\xaf\x02\x12\x10\n" +
	"\vNotModified\x10\xb0\x02\x12\r\n" +
	"\bUseProxy\x10\xb1\x02\x12\x16\n" +
	"\x11TemporaryRedirect\x10\xb3\x02\x12\x16\n" +
	"\x11PermanentRedirect\x10\xb4\x02\x12\x0f\n" +
	"\n" +
	"BadRequest\x10\x90\x03\x12\x11\n" +
	"\fUnauthorized\x10\x91\x03\x12\x14\n" +
	"\x0fPaymentRequired\x10\x92\x03\x12\x0e\n" +
	"\tForbidden\x10\x93\x03\x12\r\n" +
	"\bNotFound\x10\x94\x03\x12\x15\n" +
	"\x10MethodNotAllowed\x10\x95\x03\x12\x12\n" +
	"\rNotAcceptable\x10\x96\x03\x12 \n" +
	"\x1bProxyAuthenticationRequired\x10\x97\x03\x12\x13\n" +
	"\x0eRequestTimeout\x10\x98\x03\x12\r\n" +
	"\bConflict\x10\x99\x03\x12\t\n" +
	"\x04Gone\x10\x9a\x03\x12\x13\n" +
	"\x0eLengthRequired\x10\x9b\x03\x12\x17\n" +
	"\x12PreconditionFailed\x10\x9c\x03\x12\x14\n" +
	"\x0fPayloadTooLarge\x10\x9d\x03\x12\x0f\n" +
	"\n" +
	"URITooLong\x10\x9e\x03\x12\x19\n" +
	"\x14UnsupportedMediaType\x10\x9f\x03\x12\x18\n" +
	"\x13RangeNotSatisfiable\x10\xa0\x03\x12\x16\n" +
	"\x11ExpectationFailed\x10\xa1\x03\x12\x17\n" +
	"\x12MisdirectedRequest\x10\xa5\x03\x12\x18\n" +
	"\x13UnprocessableEntity\x10\xa6\x03\x12\v\n" +
	"\x06Locked\x10\xa7\x03\x12\x15\n" +
	"\x10FailedDependency\x10\xa8\x03\x12\x14\n" +
	"\x0fUpgradeRequired\x10\xaa\x03\x12\x19\n" +
	"\x14PreconditionRequired\x10\xac\x03\x12\x14\n" +
	"\x0fTooManyRequests\x10\xad\x03\x12 \n" +
	"\x1bRequestHeaderFieldsTooLarge\x10\xaf\x03\x12\x18\n" +
	"\x13InternalServerError\x10\xf4\x03\x12\x13\n" +
	"\x0eNotImplemented\x10\xf5\x03\x12\x0f\n" +
	"\n" +
	"BadGateway\x10\xf6\x03\x12\x17\n" +
	"\x12ServiceUnavailable\x10\xf7\x03\x12\x13\n" +
	"\x0eGatewayTimeout\x10\xf8\x03\x12\x1c\n" +
	"\x17HTTPVersionNotSupported\x10\xf9\x03\x12\x1a\n" +
	"\x15VariantAlsoNegotiates\x10\xfa\x03\x12\x18\n" +
	"\x13InsufficientStorage\x10\xfb\x03\x12\x11\n" +
	"\fLoopDetected\x10\xfc\x03\x12\x10\n" +
	"\vNotExtended\x10\xfe\x03\x12\"\n" +
	"\x1dNetworkAuthenticationRequired\x10\xff\x032e\n" +
	"\rAuthorization\x12T\n" +
	"\x05Check\x12#.envoy.service.auth.v3.CheckRequest\x1a$.envoy.service.auth.v3.CheckResponse\"\x00BEZCgithub.com/envoyproxy/go-control-plane/envoy/service/auth/v3;authv3b\x06proto3"

var (
	file_ext_authz_proto_rawDescOnce sync.Once
	file_ext_authz_proto_rawDescData []byte
)

func file_ext_authz_proto_rawDescGZIP() []byte {
	file_ext_authz_proto_rawDescOnce.Do(func() {
		file_ext_authz_proto_rawDescData = protoimpl.X.CompressGZIP(unsafe.Slice(unsafe.StringData(file_ext_authz_proto_rawDesc), len(file_ext_authz_proto_rawDesc)))
	})
	return file_ext_authz_proto_rawDescData
}

var file_ext_authz_proto_enumTypes = make([]protoimpl.EnumInfo, 3)
var file_ext_authz_proto_msgTypes = make([]protoimpl.MessageInfo, 21)
var file_ext_authz_proto_goTypes = []any{
	(StatusCode)(0), // 0: envoy.service.auth.v3.StatusCode
	(HeaderValueOption_HeaderAppendAction)(0), // 1: envoy.service.auth.v3.HeaderValueOption.HeaderAppendAction
	(SocketAddress_Protocol)(0),               // 2: envoy.service.auth.v3.SocketAddress.Protocol
	(*CheckRequest)(nil),                      // 3: envoy.service.auth.v3.CheckRequest
	(*DeniedHttpResponse)(nil),                // 4: envoy.service.auth.v3.DeniedHttpResponse
	(*OkHttpResponse)(nil),                    // 5: envoy.service.auth.v3.OkHttpResponse
	(*CheckResponse)(nil),                     // 6: envoy.service.auth.v3.CheckResponse
	(*Status)(nil),                            // 7: envoy.service.auth.v3.Status
	(*AttributeContext)(nil),                  // 8: envoy.service.auth.v3.AttributeContext
	(*HttpStatus)(nil),                        // 9: envoy.service.auth.v3.HttpStatus
	(*HeaderValueOption)(nil),                 // 10: envoy.service.auth.v3.HeaderValueOption
	(*HeaderValue)(nil),                       // 11: envoy.service.auth.v3.HeaderValue
	(*QueryParameter)(nil),                    // 12: envoy.service.auth.v3.QueryParameter
	(*Address)(nil),                           // 13: envoy.service.auth.v3.Address
	(*SocketAddress)(nil),                     // 14: envoy.service.auth.v3.SocketAddress
	(*Metadata)(nil),                          // 15: envoy.service.auth.v3.Metadata
	(*AttributeContext_Peer)(nil),             // 16: envoy.service.auth.v3.AttributeContext.Peer
	(*AttributeContext_Request)(nil),          // 17: envoy.service.auth.v3.AttributeContext.Request
	(*AttributeContext_HttpRequest)(nil),      // 18: envoy.service.auth.v3.AttributeContext.HttpRequest
	(*AttributeContext_TLSSession)(nil),       // 19: envoy.service.auth.v3.AttributeContext.TLSSession
	nil,                                       // 20: envoy.service.auth.v3.AttributeContext.ContextExtensionsEntry
	nil,                                       // 21: envoy.service.auth.v3.AttributeContext.Peer.LabelsEntry
	nil,                                       // 22: envoy.service.auth.v3.AttributeContext.HttpRequest.HeadersEntry
	nil,                                       // 23: envoy.service.auth.v3.Metadata.FilterMetadataEntry
	(*structpb.Struct)(nil),                   // 24: google.protobuf.Struct
	(*anypb.Any)(nil),                         // 25: google.protobuf.Any
	(*wrapperspb.BoolValue)(nil),              // 26: google.protobuf.BoolValue
	(*timestamppb.Timestamp)(nil),             // 27: google.protobuf.Timestamp
}
var file_ext_authz_proto_depIdxs = []int32{
	8,  // 0: envoy.service.auth.v3.CheckRequest.attributes:type_name -> envoy.service.auth.v3.AttributeContext
	9,  // 1: envoy.service.auth.v3.DeniedHttpResponse.status:type_name -> envoy.service.auth.v3.HttpStatus
	10, // 2: envoy.service.auth.v3.DeniedHttpResponse.headers:type_name -> envoy.service.auth.v3.HeaderValueOption
	10, // 3: envoy.service.auth.v3.OkHttpResponse.headers:type_name -> envoy.service.auth.v3.HeaderValueOption
	24, // 4: envoy.service.auth.v3.OkHttpResponse.dynamic_metadata:type_name -> google.protobuf.Struct
	10, // 5: envoy.service.auth.v3.OkHttpResponse.response_headers_to_add:type_name -> envoy.service.auth.v3.HeaderValueOption
	12, // 6: envoy.service.auth.v3.OkHttpResponse.query_parameters_to_set:type_name -> envoy.service.auth.v3.QueryParameter
	7,  // 7: envoy.service.auth.v3.CheckResponse.status:type_name -> envoy.service.auth.v3.Status
	4,  // 8: envoy.service.auth.v3.CheckResponse.denied_response:type_name -> envoy.service.auth.v3.DeniedHttpResponse
	5,  // 9: envoy.service.auth.v3.CheckResponse.ok_response:type_name -> envoy.service.auth.v3.OkHttpResponse
	24, // 10: envoy.service.auth.v3.CheckResponse.dynamic_metadata:type_name -> google.protobuf.Struct
	25, // 11: envoy.service.auth.v3.Status.details:type_name -> google.protobuf.Any
	16, // 12: envoy.service.auth.v3.AttributeContext.source:type_name -> envoy.service.auth.v3.AttributeContext.Peer
	16, // 13: envoy.service.auth.v3.AttributeContext.destination:type_name -> envoy.service.auth.v3.AttributeContext.Peer
	17, // 14: envoy.service.auth.v3.AttributeContext.request:type_name -> envoy.service.auth.v3.AttributeContext.Request
	20, // 15: envoy.service.auth.v3.AttributeContext.context_extensions:type_name -> envoy.service.auth.v3.AttributeContext.ContextExtensionsEntry
	15, // 16: envoy.service.auth.v3.AttributeContext.metadata_context:type_name -> envoy.service.auth.v3.Metadata
	19, // 17: envoy.service.auth.v3.AttributeContext.tls_session:type_name -> envoy.service.auth.v3.AttributeContext.TLSSession
	0,  // 18: envoy.service.auth.v3.HttpStatus.code:type_name -> envoy.service.auth.v3.StatusCode
	11, // 19: envoy.service.auth.v3.HeaderValueOption.header:type_name -> envoy.service.auth.v3.HeaderValue
	26, // 20: envoy.service.auth.v3.HeaderValueOption.append:type_name -> google.protobuf.BoolValue
	1,  // 21: envoy.service.auth.v3.HeaderValueOption.append_action:type_name -> envoy.service.auth.v3.HeaderValueOption.HeaderAppendAction
	14, // 22: envoy.service.auth.v3.Address.socket_address:type_name -> envoy.service.auth.v3.SocketAddress
	2,  // 23: envoy.service.auth.v3.SocketAddress.protocol:type_name -> envoy.service.auth.v3.SocketAddress.Protocol
	23, // 24: envoy.service.auth.v3.Metadata.filter_metadata:type_name -> envoy.service.auth.v3.Metadata.FilterMetadataEntry
	13, // 25: envoy.service.auth.v3.AttributeContext.Peer.address:type_name -> envoy.service.auth.v3.Address
	21, // 26: envoy.service.auth.v3.AttributeContext.Peer.labels:type_name -> envoy.service.auth.v3.AttributeContext.Peer.LabelsEntry
	27, // 27: envoy.service.auth.v3.AttributeContext.Request.time:type_name -> google.protobuf.Timestamp
	18, // 28: envoy.service.auth.v3.AttributeContext.Request.http:type_name -> envoy.service.auth.v3.AttributeContext.HttpRequest
	22, // 29: envoy.service.auth.v3.AttributeContext.HttpRequest.headers:type_name -> envoy.service.auth.v3.AttributeContext.HttpRequest.HeadersEntry
	24, // 30: envoy.service.auth.v3.Metadata.FilterMetadataEntry.value:type_name -> google.protobuf.Struct
	3,  // 31: envoy.service.auth.v3.Authorization.Check:input_type -> envoy.service.auth.v3.CheckRequest
	6,  // 32: envoy.service.auth.v3.Authorization.Check:output_type -> envoy.service.auth.v3.CheckResponse
	32, // [32:33] is the sub-list for method output_type
	31, // [31:32] is the sub-list for method input_type
	31, // [31:31] is the sub-list for extension type_name
	31, // [31:31] is the sub-list for extension extendee
	0,  // [0:31] is the sub-list for field type_name
}

func init() { file_ext_authz_proto_init() }
func file_ext_authz_proto_init() {
	if File_ext_authz_proto != nil {
		return
	}
	file_ext_authz_proto_msgTypes[3].OneofWrappers = []any{
		(*CheckResponse_DeniedResponse)(nil),
		(*CheckResponse_OkResponse)(nil),
	}
	file_ext_authz_proto_msgTypes[10].OneofWrappers = []any{
		(*Address_SocketAddress)(nil),
	}
	file_ext_authz_proto_msgTypes[11].OneofWrappers = []any{
		(*SocketAddress_PortValue)(nil),
		(*SocketAddress_NamedPort)(nil),
	}
	type x struct{}
	out := protoimpl.TypeBuilder{
		File: protoimpl.DescBuilder{
			GoPackagePath: reflect.TypeOf(x{}).PkgPath(),
			RawDescriptor: unsafe.Slice(unsafe.StringData(file_ext_authz_proto_rawDesc), len(file_ext_authz_proto_rawDesc)),
			NumEnums:      3,
			NumMessages:   21,
			NumExtensions: 0,
			NumServices:   1,
		},
		GoTypes:           file_ext_authz_proto_goTypes,
		DependencyIndexes: file_ext_authz_proto_depIdxs,
		EnumInfos:         file_ext_authz_proto_enumTypes,
		MessageInfos:      file_ext_authz_proto_msgTypes,
	}.Build()
	File_ext_authz_proto = out.File
	file_ext_authz_proto_goTypes = nil
	file_ext_authz_proto_depIdxs = nil
}
